## Source Annotations
Mark Pilgrim, Dive Into HTML5, Chapter 4: Let’s Call It a Draw(ing Surface)
[http://diveintohtml5.info/canvas.html]
This chapter of Pilgrim’s Dive Into HTML5 focuses on the basics of the ‘canvas’ element, providing a definition and showing the syntax for it in HTML code. The HTML element will define how large the canvas will be on the web page, and can be assigned an id attribute to allow the developer to work with it more easily. More importantly, it demonstrates that the actual drawing work in the canvas element is done through JavaScript. Pilgrim presents tutorials on how to do specific functions with the canvas, such as drawing easily-editable nonpermanent “paths,” rendering text, creating color gradients and rendering images with either an ‘img’ element or an ‘Image()’ object. Pilgrim shows some JavaScript that allows ‘canvas’ to work properly with older versions of Internet Explorer that don’t natively support it, and ends his chapter with a step-by-step procedure on how to set up a simple board game in ‘canvas.’


Steve Fulton & Jeff Fulton, HTML5 Canvas, Chapter 8: Canvas Games: Part 1
[http://chimera.labs.oreilly.com/books/1234000001654/ch08.html#geo_blaster_game_structure]
With previous chapters of their book dedicated to the basics, the Fultons go more in-depth on how ‘canvas’ is used for video game development. Compared to Pilgrim’s article, HTML5 Canvas covers some different topics surrounding ‘canvas,’ such as how it compares to Adobe Flash with advantages and disadvantages of each. This chapter walks through the development of an Asteroids¬-style game in HTML5 called Geo Blaster Basic. This requires, according to the authors, four needed assets: the background, the player character, an enemy character and some ‘rocks’ for the player to shoot. Fulton and Fulton show us how ‘canvas’ and the JavaScript surrounding the element create these four assets. Drawing paths allows the developer to render the player and enemy characters, and the JavaScript function ‘setTimeout()’ allows those characters to animate on a frame-by-frame basis. The keyPressList function is manipulated to allow a player to control their character with inputs from the keyboard. Creating a ‘state machine’ allows the game code to handle different states that each need their own game logic, such as the title screen, when a player starts a level and when the player’s character dies. Finally, JavaScript allows the developer to create their own functions that will pertain to the events of the game.

## Historicizing Memo
For my historicizing project, I will be examining browser-based video games developed using CSS and HTML5. I will be integrating this project with the “Historicizing a Web Technology” assignment, which requires research of a “soft” technology such as elements in HTML or CSS in order to place it in a proper historical context. The <canvas> element in HTML5 is important for rendering graphics and animations in browser-based games and is therefore a core focus of my project. I will isolate 2 or 3 practices surrounding the use of <canvas> and connect them with a practice framework of writing to older video game practices. From there, I’ll examine HTML5 browser games’ place in the larger context of video games and how they draw from earlier forms of video games and gaming technology as well as earlier forms of the web technologies that the HTML5 needed to draft these games evolved from. I will also work to understand how browser games relate to traditional print media.

Some potential directions I’ll take this project are:

**How to use the graphics in ‘canvas’ to design a good platform-genre game level**

	In platform-genre games, there are a few best practices to follow in order to design a good level. In my opinion, a good level will be intuitive to move through, never making the player take a blind guess on where to go. The player should have ample time and room to prepare for the tough obstacles, and those obstacles should be spaced evenly throughout a level so they aren’t too numerous or encountered in quick succession. Small enemies to engage with safely and items or secrets to find also go a long way in keeping the player engaged with the level, providing a “break” of sorts from the main obstacles. These are rather vague and general guidelines, and different game developers may have different approaches to fulfilling the guidelines as they build their game in HTML5. I would research how different developers use the ‘canvas’ element to fulfill the practices of a good platformer level. Even though every developer would be working with the same tool, ‘canvas’ in HTML5, each one will have their own proficiency or interpretations of the element that guide how they create their work. An example might be one developer that tries to work as efficiently as possible, only creating and rendering the objects that the player interacts with directly, against another developer that builds a more fleshed-out game world that tries to be more immersive to the player, despite adding elements that aren’t strictly necessary or efficient.
    
**‘Canvas’: before and after**

	Developers for HTML only implemented the ‘canvas’ element recently, with the element itself debuting in the release of HTML5. Prior to ‘canvas,’ a game developer had to make use of other methods to build and render their game. I would research how the presence of the ‘canvas’ element influences the code writing that goes into the game, using a particular pre-‘canvas’ game I’m very familiar with, Pokémon Showdown!, as the core for my analysis. For reference, Pokémon Showdown! simulates the gameplay of battles in the Pokémon games, allowing players to select Pokémon to build their team and battle other players on the site using one of many potential rulesets. The game uses complex JavaScript to recreate the battle system of the Pokémon games, replicating as closely as possible the damage calculations and random number generation the original games use. The Pokémon themselves and attack animations are represented in .gif files contained within ‘div’ tags.




